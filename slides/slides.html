<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Testing in node.js</title>

  <meta name="description" content="A talk about helpful testing techniques for node.js apps">
  <meta name="author" content="Nicole Rauch and Andreas Leidig">

  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/sky.css" id="theme"><!-- changed to sky -->
  <style type="text/css">
    .reveal section img {
      background: none; 
      border: none; 
      box-shadow: none
    }
  </style>

  <!-- For syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
    if (window.location.search.match(/print-pdf/gi)) {
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'css/print/pdf.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    }
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<!-- Title page -->
<section>
  <h1>Testing in node.js</h1>

  <h3>Interesting and Helpful Techniques</h3>

  <p>
    <small>By Nicole Rauch and Andreas Leidig</small>
  </p>
</section>

<!-- CONTEXT -->
<section>
  <section>
    <h2>Context</h2>

    <ul>
      <li>Server application running on node.js</li>
      <li>Community platform</li>
      <li>2 main contributors</li>
    </ul>

    <aside class="notes"></aside>
  </section>

  <section>
    <h2>Facts</h2>

    <ul>
      <li>Live since August 2013</li>
      <li>About 850 registered members</li>
      <li>3-tier Architecture</li>
      <li>Stateless Backend</li>
    </ul>

    <aside class="notes"></aside>
  </section>
</section>
    
<!-- This Workshop -->
<section>
  <section>
      <h2>Workshop Agenda</h2>
      <ul>
        <li>We present a problem we ran into</li>
        <li>We give you some time to think about possible solutions</li>
            <ul>
              <li>Please work in pairs or triples</li>
            </ul>
        <li>We discuss your ideas</li>
        <li>We present our current solution</li>
      </ul>
  </section>
    
    <section>
    <h2>Please ...</h2>
      <ul>
        <li>Most examples are tiny and minimalist</li>
        <li>(and it was hard to get them so small!)</li>
        <li>Please, no discussions about overengineered solutions to trivial problems</li>
        <li>We can show you the original code if you like...</li>
      </ul>
  </section>

  <section>
    <h2>Foundations</h2>
      <ul>
        <li>Problems are available in sourcecode</li>
        <li>Code is executable, tests can be run</li>
        <li>You can try out your ideas in the code</li>
        <li>Solutions are available in sourcecode as well</li>
        <li>If you cheat, please be silent in discussions</li>
      </ul>
  </section>

  <section>
      <h2>Laptop Setup Time</h2>
      Clone <code>https://github.com/NicoleRauch/NodeTestingTechniques</code>
  </section>
</section>

<!-- COOL BEANS -->
<section>
  <section>
    <h2>Indirect dependencies</h2>
  
    <p>
      <b>Problem:</b> How to stub dependencies at different layers?
    </p>

    <aside class="notes">
      Hier die Slides f√ºr Cool Beans.
    </aside>
  </section>
    
  <section>
    <h2>Application Structure</h2>
      <img src="pics/MembersModule.svg">
  </section>
    
  <section>
    index.js:
    <pre class="javascript"><code data-trim contenteditable>
var service = require('./membersService');

app.get('/', function (req, res, next) {
  service.allMembers(function (err, members) {
    res.render('index', { members: members });
  });
});
    </code></pre>
      
      membersService.js:
    <pre class="javascript"><code data-trim contenteditable>
var store = require('./memberstore');

module.exports = {
  allMembers: function (callback) {
    store.allMembers(callback);
  }
};
    </code></pre>
      
      memberstore.js:
    <pre class="javascript"><code data-trim contenteditable>
var persistence = require('../persistence/persistence')('memberstore');

module.exports = {
  allMembers: function (callback) {
    persistence.list({lastname: 1, firstname: 1}, callback);
  }
};
    </code></pre>
    </section>  
    
    <section>
      <h2>Unit and Integration Tests</h2>
        <p>
        Stubbing allows to isolate one or several modules
        </p>
        <img src="pics/MembersModule.svg" width="60%">
        <p>
        But how?
        </p>
        
    <aside class="notes">
      (attention! why would we want to do this?)
    </aside>

    </section>
    
    <section>
      <p>
      <b>Interesting:</b> <code>require</code> promises a singleton module
      </p>
      <p>
      <b>BUT:</b> <code>require</code> creates one singleton per import path!
      </p><br/>
      In production:
        <pre class="javascript"><code data-trim contenteditable>
var service = require('./membersService');        
        </code></pre>

      In test:
        <pre class="javascript"><code data-trim contenteditable>
var service = require('../../lib/members/membersService');        
        </code></pre>
      <br/>
      Two different instances!
    </section>  
        
    <section>
        <h2>Proxyquire</h2>
        <p>
        Replaces a <code>require</code>d module inside a module.
        </p>
        <br/>
        Sounds great - let's try this out!
    </section>
    
    <section>
      <h2>Unit Testing index.js</h2>
        <pre class="javascript"><code data-trim contenteditable>
var membersServiceStub = {
  allMembers: function (callback) {
    callback(null, [testMember]);
  }
};

var app = proxyquire('../../lib/members', {
  './membersService': membersServiceStub
});

it('lists all members', function (done) {
  request(app)
    .get('/')
    .expect(/Peter Miller \(Nickinick\)/, done);
});        
        </code></pre>
        
    <aside class="notes">
      So if we just test one module, we are fine:
      
      But if we test two modules in integration, things get slightly more complicated:
    </aside>
    </section>
    
    <section>
      <h2>Integration Testing</h2>
        Integrating 2 layers:
        <pre class="javascript"><code data-trim contenteditable>
var memberstoreStub = {
  allMembers: function (callback) {
    callback(null, [testMember]);
  }
};

var membersServiceStub = proxyquire('../../lib/members/membersService', {
  './memberstore': memberstoreStub
});

var app = proxyquire('../../lib/members', {
  './membersService': membersServiceStub
});

it('lists all members', function (done) {
  request(app)
    .get('/')
    .expect(/Peter Miller \(Nickinick\)/, done);
});        
        </code></pre>
    </section>
  
    <section>
        Integrating 3 layers:
        <pre class="javascript"><code data-trim contenteditable>
var persistenceStub = function () {
  return {
    list: function (sortOrder, callback) {
      callback(null, [testMember]);
    } }; };

var memberstoreStub = proxyquire('../../lib/members/memberstore', {
  '../persistence/persistence': persistenceStub
});

var membersServiceStub = proxyquire('../../lib/members/membersService', {
  './memberstore': memberstoreStub
});

var app = proxyquire('../../lib/members', {
  './membersService': membersServiceStub
});

it('lists all members', function (done) {
  request(app)
    .get('/')
    .expect(/Peter Miller \(Nickinick\)/, done);
});        
        </code></pre>
    </section>
  
  <section>
      <h2>What would be a better solution?</h2>
      Try out
      Discuss
  </section>
    
    <section>
        <h2>Our Solution</h2>
        We decided to use...
    </section>

    <section>
        <h2>Dependency Injection</h2>
    </section>

    <section>
        <p>
        We use a framework called <code>CoolBeans</code>.
        </p>
        <br/>
        We define our singleton beans:
        <pre class="javascript"><code data-trim contenteditable>
{
  "membersApp": {"module": "./lib/members"},
  "membersService": {"module": "./lib/members/membersService"},
  "memberstore": {"module": "./lib/members/memberstore"},
  "membersPersistence": {
    "module": "./lib/persistence/persistence",
    "constructorArgs": { "collectionName": "memberstore" }
  },
  "member": {"module": "./lib/members/member"}
}
        </code></pre>
        
        We plug them into nconf:
        <pre class="javascript"><code data-trim contenteditable>
function createConfiguration() {
  nconf.defaults({
    // ...
    beans: new Beans('./config/beans.json')
  });
  return nconf;
}
        </code></pre>
        
    </section>
    
    <section>
        And use them in production:
        <pre class="javascript"><code data-trim contenteditable>
var service = require('nconf').get('beans').get('membersService');
        </code></pre>
        
        and test:
        <pre class="javascript"><code data-trim contenteditable>
var service = require('../../configure').get('beans').get('membersService');
        </code></pre>
        
        Stubbing for a single layer test:
        <pre class="javascript"><code data-trim contenteditable>
  beforeEach(function () {
    sinon.stub(membersService, 'allMembers', function (callback) {
      callback(null, [testMember]);
    });
  });
        </code></pre>
        
        Stubbing for a two-layer test:
        <pre class="javascript"><code data-trim contenteditable>
  beforeEach(function () {
    sinon.stub(memberstore, 'allMembers', function (callback) {
      callback(null, [testMember]);
    });
  });
        </code></pre>
        
        Stubbing for a three-layer test:
        <pre class="javascript"><code data-trim contenteditable>
  beforeEach(function () {
    sinon.stub(membersPersistence, 'list', function (sortOrder, callback) {
      callback(null, [testMember]);
    });
  });
        </code></pre>
        
    </section>

</section>

<!-- NCONF -->
<section>
  <section>
    <h2>Application Configuration</h2>

    <p>
      <b>Problem:</b> We configure our application via a configuration framework. How can we provide a standardized test configuration with minimal setup?
    </p>
    <p>
      We do not want to change the configuration in each test setup, we only want "<i>the</i> test configuration". (There can be exceptions to this rule)
    </p>

    <aside class="notes">
      Hier die Slides f√ºr nconf.
    </aside>
  </section>

  <section>
    <h3>Testing with dependencies on the local environment?</h3>

    <p>This is not acceptable. We need to provide an independent testing configuration.</p>
    <ul>
      <li>Logging</li>
      <li>Passwords</li>
      <li>Special User Privileges</li>
      <li>Local Paths</li>
      <li>‚Ä¶</li>
    </ul>

    <aside class="notes">
      <p>Anything we need to be individual depending on the environment.</p>
      <p>The database connection will never be overridden.</p>
    </aside>
  </section>

  <section>
    <h3>EXAMPLE</h3>
    <h4>Superuser Privileges</h4>

    <p>A configuration file defines the ids of users that have superuser privileges.</p>
    <p>We want to test that the privileges have an effect.</p>
    <p>We chose <code>nconf.js</code> for that job</p>

    <aside class="notes">
      <p>Show in code</p>
    </aside>
  </section>

  <section>
    <h3>EXAMPLE</h3>
    
    <h4>configure.js</h4>
    <pre class="javascript"><code data-trim contenteditable>
var nconf = require('nconf');
nconf.file('superusers', './config/superusers.json');
module.exports = nconf;
    </code></pre>

    <h4>superusers.json</h4>
    <pre class="javascript"><code data-trim contenteditable>
{ "superuser" : ["Balli","Rums"] }
    </code></pre>

    <h4>usage</h4>
    <pre class="javascript"><code data-trim contenteditable>
// index.js
res.render('index', { members: members, superusers: require('nconf').get('superuser') });

// index.jade
if (superusers.indexOf(member.nickname) > -1)
  |  is a SUPERUSER
    </code></pre>
    
    <h4>test setup</h4>
    <pre class="javascript"><code data-trim contenteditable>
beforeEach(function (done) {
  nconf.set('superuser', 'Charli', function () {  done(); });
});
    </code></pre>

    <aside class="notes">
      <p>Problem: it has to be done in every test.</p>
    </aside>
  </section>

  <section>
    <h1>CODE</h1>

    <aside class="notes">
      <p>Switch to workspace "Configuration for Tests - problem"</p>
    </aside>
  </section>

  <section>
    <h2>What would be a better solution?</h2>

    <aside class="notes">
      <p>Switch to workspace "ConfigurationForTests/problem"</p>
    </aside>
  </section>

  <section>
    <h2>Our solution</h2>

    <p>We use <code>nconf.overrides()</code> function for that to provide a standardised test setup.</p>

    <pre class="javascript"><code data-trim contenteditable>
var nconf = require('nconf');
nconf.overrides({ superuser: ['Charli'] });
module.exports = require('../configure');
    </code></pre>

    <p>And call this module from the test</p>

    <pre class="javascript"><code data-trim contenteditable>
// before:
var nconf = require('../../configure');
      
// now:
require('../../testutil/configureForTest');
    </code></pre>

    <p>Additionally, we do not need to setup anything in a <code>beforeEach</code></p>

    <aside class="notes">
      <p>Switch to workspace "ConfigurationForTests/solution"</p>
    </aside>
  </section>

<!-- Cool Beans / nconf extra -->
  <section>
    <h1>Extra</h1>
    <h2>Hide your ressources</h2>
  
    <p>
      <b>Problem:</b> How can you protect external ressources from accidental change during a (potentially broken) test?
    </p>

    <aside class="notes">
      Database / 3rd party services / files
    </aside>
  </section>

  <section>
    <h2>Our solution</h2>
  
    <p>
      Combine <code>CoolBeans</code> with <code>nconf</code> by replacing some beans with fake implementations. 
    </p>

    <h4>beans.json</h4>
    <pre class="javascript"><code data-trim contenteditable>
"sympa": {"module": "./lib/groups/sympa"},
"activitiesPersistence": {
  "module": "./lib/persistence/persistence",
  "constructorArgs": { "collectionName": "activitystore" }
},
    </code></pre>

    <h4>testbeans.json</h4>
    <pre class="javascript"><code data-trim contenteditable>
"sympa": {},
"activitiesPersistence": {"module": "./test/persistence/testpersistence"},
    </code></pre>

    <aside class="notes">
      Database / 3rd party services / files
    </aside>
  </section>
</section>

<!-- VARIOUS TESTING NEEDS -->
<section>
  <section>
    <h2>Testing Needs</h2>
  
    <p>
      <b>Problem:</b> The application requires different testing techniques depending on the level of testing. How to adapt to various testing needs?
    </p>

    <aside class="notes">
      Hier die Slides.
    </aside>
  </section>
</section>

<!-- UI tests / Application tests -->
<section>
  <section>
    <h2>UI Tests</h2>
  
    <p>
      <b>Problem:</b> How can I perform UI tests with only setting up a minimal part of the application?
    </p>

    <aside class="notes">
      Hier die Slides f√ºr app testing.
    </aside>
  </section>
</section>

<!-- DB tests -->
<section>
  <!-- VORHER: nconf -->
  <section>
    <h2>DB Tests</h2>
  
    <p>
      <b>Problem:</b> How to test a database in integration?
    </p>
    <ul>
      <li>We use native queries and other database features in our code.</li>
      <li>In our test configuration, we replace the module that connects to the database by a fake.</li>
    </ul>
    
    <ul>
      <li>Question: How to test the database integration?</li>
      <li>Question: How to test native queries?</li>
    </ul>

    <aside class="notes">
      Hier die Slides.
    </aside>
  </section>
  
  <section>
    <h2>DB Tests</h2>
  
    <p>
      <b>Our Solution</b>
    </p>
    <ul>
      <li>We set up a second test configuration where we connect to a test database (i.e. a special collection in our mongoDB).</li>
      <li>Nice: We cannot mess up production data even if we run the tests on the production system.</li>
    </ul>
    
    <aside class="notes">
      <p>This is our configuration for tests with DB:</p>
      <p>https://github.com/softwerkskammer/Agora/blob/master/testutil/configureForTestWithDB.js</p>
      <p>It uses the following beans definitions for the modules that connect to the database:</p>
      <p>https://github.com/softwerkskammer/Agora/blob/master/config/testbeansWithDB.json</p>
      <p>So far, only groupsPersistence, activitiesPersistence and sympaPersistence are being connected to the database; the others still point to the persistence fake because there are currently no integration tests for them.</p>
      
      <p>The actual database tests are now pretty straightforward:</p>
      <p>https://github.com/softwerkskammer/Agora/blob/master/testWithDB/activitiesDB/activities_index_upcoming_past_test.js</p>
      <p>In the setup, clear the database, persist the desired objects, run the test and check the results.</p>

    </aside>
  </section>
</section>

<!-- RACE CONDITIONS -->
<section>
  <!-- VORHER: CoolBeans App/UI Tests DB Tests -->
  <section>
    <h2>DB Race Conditions</h2>

    <p>
      <b>Problem:</b> How to test race conditions on a database?
    </p>

    <ul>
      <li>To prevent data loss due to concurrent modification of data, we use version counters.</li>
      <li>If feasible, we apply automatic retries.</li>
      <li>Otherwise, the user is asked to redo his operation.</li>
    </ul>

    <aside class="notes">
      Hier die Slides.
    </aside>
  </section>

  <section>
    <h2>DB Race Conditions</h2>

    <p>
      <b>Question:</b> How can we test that
    </p>

    <ul>
      <li>there will be no data loss due to race conditions?</li>
      <li>the automatic retry succeeds?</li>
    </ul>

    <aside class="notes">
      Hier die Slides.
    </aside>
  </section>
  
  <section>
    <h2>DB Race Conditions</h2>

    <p>
      <b>Our Solution:</b> (No-data-loss test)
    </p>

    <ul>
      <li>Actual race condition (i.e.~interleaved load-modify-save sequence) cannot be established in automated test</li>
      <li>Trick:</li>
      <ul>
        <li>stub the load operation so that it returns the object in question <b>before</b> the concurrent modification</li>
        <li>initialize database with object in question <b>after</b> the concurrent modification</li>
        <li>this simulates that the concurrent modification takes place after the load operation but before the save operation that is performed in our test</li>
      </ul>
      <li>Test checks that the concurrent modification is still present in the object in question after the attempted save operation.</li>
    </ul>

    <aside class="notes">
      Hier die Slides.
    </aside>
  </section>
  
  <section>
    <h2>DB Race Conditions</h2>

    <p>
      <b>Our Solution:</b> (Automatic-retry test)
    </p>

    <ul>
      <li>To test the automatic retry:</li>
      <ul>
        <li>stub the load operation so that it returns the object in question <b>before</b> the concurrent modification on the first invocation</li>
        <li>and the object in question <b>after</b> the concurrent modification on the second invocation (i.e.~when automatic retry is triggered)</li>
      </ul>
      <li>Test checks that the modification from our test as well as the concurrent modification is present in the object in question after the save operation.</li>
    </ul>

    <aside class="notes">
      Hier die Slides.
    </aside>
  </section>
</section>

<!-- DOM tests-->
<section>
  <section>
    <h2>DOM Tests</h2>

    <p>
      <b>Problem:</b> How can I test frontend code that requires a DOM if all I have is jade template files (but no html files)?
    </p>

    <aside class="notes">
      Hier die Slides f√ºr DOM testing.
    </aside>
  </section>
  
  <section>
    <h2>DOM Tests</h2>

    <p>We want to unit test the client side validations. This code relies heavily on DOM elements.</p>
    <p>We do not have static html files to provide a DOM for testing. 
      All our html code is rendered at runtime from jade templates and also provided with runtime state (via fields in <code>res.locals</code>)</p>

    <aside class="notes">
      Hier die Slides f√ºr DOM testing.
    </aside>
  </section>
  
  <section>
    <h2>form.jade</h2>

    <pre class="javascript"><code data-trim contenteditable>
doctype html

html
  head
    script(src='/jquery.js')
    script(src='/jquery.validate.js')
    script(src='/check-form.js')
    title SPA fun with jade files
  body
    h1 SPA
    form#theform(action='/submit', method='post')
      label text:
      input(type='text', name='text', placeholder='text')
      button(type='submit') OK
    hr
    p The injected variable is #{val.words}
    </code></pre>
    <p>The input field is marked mandatory via JavaScript (<code>jquery-validation</code>)</p>
    <aside class="notes">
      <p>#{val.words} is the runtime state</p>
      <p>We only want to check that 'text' is mandatory</p>
    </aside>
  </section>
  
  <section>
    <h2>check-form.js</h2>

    <pre class="javascript"><code data-trim contenteditable>
var form_validator;
var initValidator = function () {
  form_validator = $('#theform').validate({
    rules: { text: 'required' },
  });
  form_validator.form();
  var handler = function (element) {
    return function () { form_validator.element(element); };
  };
  ['#theform [name=text]'].forEach(function (each) {
    $(each).keyup(handler(each));
  });
};
$(document).ready(initValidator);
    </code></pre>
  </section>
  
  <section>
    <h2>The Test</h2>

    <pre class="javascript"><code data-trim contenteditable>
describe('The Form', function () {
  var checkFieldMandatory = function (fieldname) {
    var field = $(fieldname);
    field.val('');
    expect(form_validator.element(field)).toBe(false);
    expect(form_validator.errorList[0].message)
      .toBe('This field is required.');
    field.val('.');
    expect(form_validator.element(field)).toBe(true);
  };
      
  it('checks that "text" is mandatory', function () {
    checkFieldMandatory('#theform [name=text]');
  });
});
    </code></pre>
  </section>

  <section>
    <h1>CODE</h1>
  </section>
  
  <section>
    <h2>Our Solution</h2>
    <ol>
      <li>Extract the form to a jade mixin. So it can be included easily from some other jade file.</li>
      <li>Create a new jade file including all our form mixins.</li>
      <li>Create a dummy file for all needed <code>res.locals</code> state</li>
      <li>Compile this jade file via a grunt task.</li>
    </ol>
  </section>
  
  <section>
    <h4>The Mixin</h4>
    <pre class="javascript"><code data-trim contenteditable>
mixin theform(value)
  form#theform(action='/submit', method='post')
    label text:
    input(type='text', name='text', placeholder='text')
    button(type='submit') OK
  hr
  p The injected variable is #{value.words}
    </code></pre>
    <h4>forms.jade</h4>
    <pre class="javascript"><code data-trim contenteditable>
include ../../views/form
+theform(val)
    </code></pre>
    <h4>locals</h4>
    <pre class="javascript"><code data-trim contenteditable>
module.exports = {val: {words: 'some text'}};
    </code></pre>
  </section>

  <section>
    <h2>Gruntfile</h2>
    <pre class="javascript"><code data-trim contenteditable>
jade: {
  compile: {
    options: {
      data: function () {
        // include the locals
        return require('./frontendtests/fixtures/locals');
      }
    },
    files: {
      // files to compile
      'frontendtests/fixtures/forms.html': 'frontendtests/fixtures/forms.jade'
    }
  }
}
    </code></pre>
  </section>

  <section>
    <h1>CODE</h1>
  </section>

</section>

<!-- coverage tests-->
<section>
  <section>
    <h2>Coverage Instrumentation</h2>

    <p>
      <b>Problem:</b> Coverage measure instruments all code, even if it is run inside the mongodb. Thus breaking it.
    </p>

    <aside class="notes">
      Hier die Slides.
    </aside>
  </section>
  
  <section>
    <h2>Overall Coverage</h2>

    <p>
      <b>Problem:</b> We have different test runs that all measure coverage. How can we get an overall coverage?
    </p>

    <aside class="notes">
      Hier die Slides.
    </aside>
  </section>
</section>

<!-- Thank You -->
<section>
<h1>
  Thank you
</h1>  
</section>

</div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: true,

    theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
    transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
      width: 1366,
      height: 800,

    // Factor of the display size that should remain empty around the content
      margin: 0.1,

    // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.0,

    // Transition style
    transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

    // Transition speed
    transitionSpeed: 'default', // default/fast/slow

    // Transition style for full page slide backgrounds
    backgroundTransition: 'none', // default/none/slide/concave/convex/zoom

    // Parallax scrolling
    // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
    // parallaxBackgroundSize: '2100px 900px',

    // Optional libraries used to extend on reveal.js
    dependencies: [
      { src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
      { src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true, condition: function () { return !!document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function () { return !!document.body.classList; } }
    ]
  });

</script>

</body>
</html>
